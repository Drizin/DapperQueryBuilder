using Dapper;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Text.RegularExpressions;

namespace DapperQueryBuilder
{
    /// <summary>
    /// A List of Parameters that are passed to Dapper methods
    /// </summary>
    public class ParameterInfos : Dictionary<string, ParameterInfo>, SqlMapper.IDynamicParameters, SqlMapper.IParameterCallbacks
    {
        #region members
        private DynamicParameters _dapperParameters = null;
        #endregion

        #region ctors
        /// <summary>
        /// List of SQL parameters which are passed to Dapper
        /// </summary>
        public ParameterInfos() : base(StringComparer.OrdinalIgnoreCase)
        {
        }
        #endregion

        #region DapperParameters
        /// <summary>
        /// Convert the current parameters into Dapper Parameters, since Dapper will automagically set DbTypes, Sizes, etc, and map to our databases
        /// </summary>
        public virtual DynamicParameters DapperParameters
        {
            get
            {
                if (_dapperParameters == null)
                {
                    _dapperParameters = new DynamicParameters();
                    foreach (var parameter in this.Values)
                    {
                        _dapperParameters.Add(parameter.Name, parameter.Value, parameter.DbType, parameter.ParameterDirection, parameter.Size);
                    }
                }
                return _dapperParameters;
            }
        }
        #endregion

        /// <summary>
        /// Add a parameter to this dynamic parameter list.
        /// </summary>
        public void Add(ParameterInfo parameter)
        {
            this[parameter.Name] = parameter;
        }

        bool IsEnumerable(object value)
        {
            if (value == null || value is DBNull)  //SqlMapper.GetDbType
                return false;
            Type t = value.GetType();
            return t != typeof(string) && typeof(IEnumerable).IsAssignableFrom(t);
            //TODO: use Dapper SqlMapper.LookupDbType ?
        }

        /// <summary>
        /// Add a parameter to this dynamic parameter list (reusing existing parameter if possible)
        /// </summary>
        public string Add(object value, DbType? dbType = null, ParameterDirection? direction = null)
        {
            bool isEnumerable = IsEnumerable(value);
            string newParameterName = DapperQueryBuilderOptions.AutoGeneratedParameterName + (isEnumerable ? "array" : "") + Values.Count;
            if (DapperQueryBuilderOptions.ReuseIdenticalParameters)
            {
                var existingParam =
                    Values.FirstOrDefault(p =>
                        p.DbType == dbType
                        && p.ParameterDirection == direction
                        && direction == ParameterDirection.Input
                        && ((p.Value == null && value == null) || (p.Value != null && p.Value.Equals(value)))
                        );

                if (existingParam != null)
                    return existingParam.Name;
            }

            var parameter = new ParameterInfo(newParameterName, value, dbType, direction);

            this[parameter.Name] = parameter;
            return newParameterName;
        }
        
        /// <summary>
        /// Get parameter value
        /// </summary>
        public T Get<T>(string key) => (T)this[key].Value;

        /// <summary>
        /// Parameter Names
        /// </summary>
        public HashSet<string> ParameterNames => new HashSet<string>(this.Keys);

        void SqlMapper.IDynamicParameters.AddParameters(IDbCommand command, SqlMapper.Identity identity)
        {
            // we just rely on Dapper.DynamicParameters which implements IDynamicParameters like a charm
            ((SqlMapper.IDynamicParameters)DapperParameters).AddParameters(command, identity);
        }

        /// <summary>
        /// After Dapper command is executed, we should get output/return parameters back
        /// </summary>
        void SqlMapper.IParameterCallbacks.OnCompleted()
        {
            var dapperParameters = DapperParameters;

            // Update output and return parameters back
            foreach (var oparm in this.Values.Where(p => p.ParameterDirection != ParameterDirection.Input))
            {
                oparm.Value = dapperParameters.Get<object>(oparm.Name);
                oparm.OutputCallback?.Invoke(oparm.Value);
            }
        }


        #region Add Existing Parameter
        /// <summary>
        /// Merges single parameter into this list. <br />
        /// Checks for name clashes, and will rename parameter if necessary. <br />
        /// Will return the name of the merged parameter.
        /// (most likely each merged parameter will get a higher auto-generated number, but it's possible that an identical type/value exists and in this case will return the existing parameter name)
        /// </summary>
        public string MergeParameter(ParameterInfo parameter)
        {
            if (DapperQueryBuilderOptions.ReuseIdenticalParameters)
            {
                var existingParam =
                    Values.FirstOrDefault(p =>
                        p.DbType == parameter.DbType
                        && p.ParameterDirection == parameter.ParameterDirection
                        && parameter.ParameterDirection == ParameterDirection.Input
                        && ((p.Value == null && parameter.Value == null) || (p.Value != null && p.Value.Equals(parameter.Value)))
                        );

                // if. we're adding a new block with @p0="Rick" but we already have @p1="Rick" in the existing statement,
                // just return "@p1" so that the "@p0" occurences in the appended block will be renamed to @p1
                if (existingParam != null)
                    return existingParam.Name;
            }

            bool isEnumerable = IsEnumerable(parameter.Value);
            string newParameterName = DapperQueryBuilderOptions.AutoGeneratedParameterName + (isEnumerable ? "array" : "") + ParameterNames.Count;

            // Create a copy, it's safer
            ParameterInfo newParameter = new ParameterInfo(
                name: newParameterName, 
                value: parameter.Value,
                dbType: parameter.DbType, 
                direction: parameter.ParameterDirection,
                size: parameter.Size, 
                precision: parameter.Precision,
                scale: parameter.Scale
            );
            newParameter.OutputCallback = parameter.OutputCallback;

            Add(newParameter);

            // if. we're adding a new block with @p0="Rick" but we already have other values @p0 and @p1 in the existing statement,
            // just return "@p2" (which is the name set in the new parameter) so that the "@p0" occurences in the appended block will be renamed to @p2
            return newParameterName;
        }

        /// <summary>
        /// Merges multiple parameters into this list. <br />
        /// Checks for name clashes, and will rename parameters if necessary. <br />
        /// If some parameter is renamed the returned Sql statement will containg the original sql replaced with new names, else (if nothing changed) returns null. <br />
        /// </summary>
        public string MergeParameters(ParameterInfos parameters, string sql)
        {
            Dictionary<string, string> renamedParameters = new Dictionary<string, string>();
            foreach (var parameter in parameters.Values)
            {
                string newParameterName = MergeParameter(parameter);
                if (newParameterName != null && parameter.Name != newParameterName)
                    renamedParameters.Add(DapperQueryBuilderOptions.DatabaseParameterSymbol + parameter.Name, DapperQueryBuilderOptions.DatabaseParameterSymbol + newParameterName);
            }
            if (renamedParameters.Any())
            {
                Regex matchParametersRegex = new Regex("(?:[,~=<>*/%+&|^-]|\\s|\\b|^)* (" + string.Join("|", renamedParameters.Select(p=>p.Key)) + ") (?:[,~=<>*/%+&|^-]|\\s|\\b|$)",
                    RegexOptions.CultureInvariant | RegexOptions.IgnorePatternWhitespace | RegexOptions.Compiled);
                string newSql = matchParametersRegex.Replace(sql, match => {
                    Group group = match.Groups[match.Groups.Count-1]; // last match is the inner parameter
                    string replace = renamedParameters[group.Value];
                    return String.Format("{0}{1}{2}", match.Value.Substring(0, group.Index - match.Index), replace, match.Value.Substring(group.Index - match.Index + group.Length));
                });
                return newSql;
            }
            return null;
        }

        #endregion


    }


}
